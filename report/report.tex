\documentclass[a4paper]{article}

\usepackage[a4paper,margin=2cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{minted}
\usepackage[clock]{ifsym}
\usepackage{subcaption} % subfigures
\usepackage{hyperref} % links in table of contents
\usepackage[strings]{underscore}
\usepackage[sorting=none]{biblatex}

\usetikzlibrary{calc,positioning,arrows.meta,decorations.pathreplacing}
\graphicspath{ {./graphics/} }

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}
\numberwithin{figure}{section}
\numberwithin{table}{section}
\renewcommand{\arraystretch}{1.5}

\newcommand{\mi}{\mintinline}
\newcommand{\NA}{---}

\title{CS2031 - Assignment 1\\MQTT}
\date{2018-12-15}
\author{\url{https://git.nul.ie/dev/pubsub}\\\url{https://github.com/devplayer0/pubsub}\\Jack O'Sullivan\\\href{mailto:osullj19@tcd.ie}{osullj19@tcd.ie}}
\bibliography{bibliography}

\begin{document}
\maketitle
\tableofcontents
\pagenumbering{gobble}

\newpage
\pagenumbering{arabic}
\section{Introduction}
\subsection{Objective}
The goal of this assignment was to develop an implementation of an MQTT-like protocol making use of some kind of Flow Control.

Classic MQTT is implemented with TCP, which means it is guaranteed to deliver messages (in order). However, this can pose issues for embedded devices with limited resources, since TCP has some non-trivial overhead. Considering that MQTT publishers are often simple, low-power sensors - this problem is amplified.
For example, the ESP8266, a popular low-cost WiFi-enabled microcontroller \cite{esp8266} has a very small amount of memory (reduced even more once firmware is loaded \cite{esp8266-lowmem}).

\medskip
By designing a custom protocol with simple flow control (to ensure at least some degree of reliability), it should be more suitable for low-power devices. UDP, which is a relatively thin layer on top of a network-layer protocol like IPv4 or IPv6 (adding only source and destination port numbers along with a checksum) should be suitable.

\subsection{Flow control and error control}
In order to build a reliable communication channel on top of UDP, some kind of flow control is required. Flow control essentially places a limit on the amount of data that be sent before the receiver acknowledges receipt of the data. Some kind of error control is also usually employed to manage out-of-order or dropped packets.

For the purposes of this report, Selective-Repeat ARQ will not be discussed since it was not implemented by the solution for this assignment.

\subsubsection{Communication without flow control}
To understand the need for flow control and error control, it helps to examine the problems encountered when not using any.
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\draw[dashed] (-3,0) -- (-3,-5) (3,0) -- (3,-5);
		\node at (-3,.3) {Sender};
		\node at (3,.3) {Receiver};

		\draw[-Latex] (-3,-1) -- node[midway,above=.5em] {Packet} (3,-2);
		\draw[-Latex] (-3,-2) -- node[midway,above=.5em] {Packet} (3,-3);
		\draw[-Latex] (-3,-3) -- node[midway,above=.5em] {Packet} (3,-4);
	\end{tikzpicture}
	\caption{No flow control: normal scenario}
	\label{fig:noflow-ok}
\end{figure}

\newpage
In Figure~\ref{fig:noflow-ok}, packets are delivered in order without any form of flow control, so clearly some form of communication is possible. However, as soon as any kind of errors appear (such as lost packets or out of order delivery), this quickly falls apart:

\begin{figure}[h!]
	\centering
	\begin{subfigure}[b][6cm][s]{.45\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[dashed] (-3,0) -- (-3,-5) (3,0) -- (3,-5);
			\node at (-3,.3) {Sender};
			\node at (3,.3) {Receiver};

			\draw[-Latex] (-3,-1) -- node[midway,above=.5em] {Packet} (3,-2);
			\draw[color=red, dash pattern=on 130pt off 99pt] (-3,-2) -- node[midway,above=.5em] {Packet} (3,-3);
			\node[color=red] at ($(-3,-2)!135pt!(3,-3)$) {$\times$};

			\draw[-Latex] (-3,-3) -- node[midway,above=.5em] {Packet} (3,-4);
		\end{tikzpicture}
		\caption{Lost packet}
		\label{fig:noflow-lost}
	\end{subfigure}
	\begin{subfigure}[b][6cm][s]{.45\textwidth}
		\begin{tikzpicture}
			\draw[dashed] (-3,0) -- (-3,-5) (3,0) -- (3,-5);
			\node at (-3,.3) {Sender};
			\node at (3,.3) {Receiver};

			\draw[-Latex] (-3,-1) -- node[midway,above=.5em] {Packet} (3,-2);
			\draw[-Latex] (-3,-2) -- node[midway,above=.5em] {Packet} (3,-4.5);
			\draw[-Latex, color=red] (-3,-3) -- node[midway,below=.5em] {Packet} (3,-3.5);
		\end{tikzpicture}
		\caption{Out of order delivery}
		\label{fig:noflow-ood}
	\end{subfigure}
	\caption{No flow control: error scenarios}
	\label{fig:noflow-errors}
\end{figure}

Figure~\ref{fig:noflow-lost} shows the second packet being dropped on its way to the receiver. There are a number of reasons that this could have happened (eg. packet contents too large for MTU). Regardless, the receiver will lose the data in the second packet completely and accept the third in its place. The receiver will always be 1 packet behind!

In Figure~\ref{fig:noflow-ood}, all of the packets are still delivered, but the third packet arrives before the second. Any switch / router between the sender and receiver could have caused the re-ordering for any reason, but since there is no way for the receiver to tell that it has received the third packet before the second, it will just accept the (most likely) invalid data in place of both the second and third packets.

\subsubsection{Stop-and-Wait}
Essentially the most simple form of flow control, Stop-and-Wait adds a an ACK (or acknowledgement) packet that the receiver must send in response to every sender packet \textbf{before the sender can continue}.
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\draw[dashed] (-3,0) -- (-3,-5.5) (3,0) -- (3,-5.5);
		\node at (-3,.3) {Sender};
		\node at (3,.3) {Receiver};

		\draw[-Latex] (-3,-.5) -- node[midway,above=.3em] {Packet} (3,-1);
		\draw[-Latex, dashed] (3,-1) -- node[midway,below=.3em] {ACK} (-3,-1.5);

		\draw[-Latex] (-3,-2.25) -- node[midway,above=.3em] {Packet} (3,-2.75);
		\draw[-Latex, dashed] (3,-2.75) -- node[midway,below=.3em] {ACK} (-3,-3.25);

		\draw[-Latex] (-3,-4) -- node[midway,above=.3em] {Packet} (3,-4.5);
		\draw[-Latex, dashed] (3,-4.5) -- node[midway,below=.3em] {ACK} (-3,-5);
	\end{tikzpicture}
	\caption{Stop-and-Wait}
	\label{fig:saw-ok}
\end{figure}

This is \textbf{flow control}: the sender can't push data down the pipe faster than the receiver can read it because it needs to wait for the ACK. Stop-and-Wait is \textit{not} error control, however:
\begin{itemize}
	\item In the case of lost packets (data or ACK), the sender will hang waiting for the client forever (to send an ACK for an unreceived packet or to re-send a dropped ACK) [Figure~\ref{fig:noflow-lost}]
	\item For packets delivered out of order, the receiver still can't tell that it has received incorrect data [Figure~\ref{fig:noflow-ood}]
\end{itemize}

\newpage
\subsubsection{Stop-and-Wait ARQ}
Stop-and-Wait ARQ (automatic repeat request) adds error control to Stop-and-Wait in order to solve the error scenarios in Figure~\ref{fig:noflow-errors}. This comes in the form of:
\begin{itemize}
	\item A 1-bit ``sequence number'' for packets and corresponding ACK's
	\item Sender timeouts: if an appropriate ACK is not received within a certain amount of time, re-send the last packet
\end{itemize}

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\draw[dashed] (-3,0) -- (-3,-5.5) (3,0) -- (3,-5.5);
		\node at (-3,.3) {Sender};
		\node at (3,.3) {Receiver};

		\draw[-Latex] (-3,-.5) -- node[midway,above=.3em] {Packet 0} (3,-1);
		\draw[-Latex, dashed] (3,-1) -- node[midway,below=.3em] {ACK 0} (-3,-1.5);

		\draw[-Latex] (-3,-2.25) -- node[midway,above=.3em] {Packet 1} (3,-2.75);
		\draw[-Latex, dashed] (3,-2.75) -- node[midway,below=.3em] {ACK 1} (-3,-3.25);

		\draw[-Latex] (-3,-4) -- node[midway,above=.3em] {Packet 0} (3,-4.5);
		\draw[-Latex, dashed] (3,-4.5) -- node[midway,below=.3em] {ACK 0} (-3,-5);
	\end{tikzpicture}
	\caption{Stop-and-Wait ARQ: normal scenario}
	\label{fig:sawe-ok}
\end{figure}

As can be seen in Figure~\ref{fig:sawe-ok}, Stop-and-Wait ARQ looks very similar to plain Stop-and-Wait (without errors). The sender still waits for an ACK from the receiver before sending another data packet. However, Stop-and-Wait ARQ allows for dropped packets (either data or ACK's) to be recovered from:
\begin{figure}[h!]
	\centering
	\begin{subfigure}[b][6.5cm][s]{.45\textwidth}
		\centering
		\begin{tikzpicture}
			\draw[dashed] (-3,0) -- (-3,-5.5) (3,0) -- (3,-5.5);
			\node at (-3,.3) {Sender};
			\node at (3,.3) {Receiver};

			\draw[-Latex] (-3,-.5) -- node[midway,above=.3em] {Packet 0} (3,-1);
			\draw[-Latex, dashed] (3,-1) -- node[midway,below=.3em] {ACK 0} (-3,-1.5);

			\draw[color=red, dash pattern=on 130pt off 99pt] (-3,-2.25) -- node[midway,above=.3em] {Packet 1} (3,-2.75);
			\node[color=red] at ($(-3,-2.25)!135pt!(3,-2.75)$) {$\times$};

			\node[anchor=east] at (-3,-3) {\large \showclock{0}{15}};
			\draw[-Latex] (-3,-3) -- node[midway,above=.3em] {Packet 1} (3,-3.5);
			\draw[-Latex, dashed] (3,-3.5) -- node[midway,below=.3em] {ACK 1} (-3,-4);
		\end{tikzpicture}
		\caption{Lost packet}
		\label{fig:sawe-lost}
	\end{subfigure}
	\begin{subfigure}[b][6.5cm][s]{.45\textwidth}
		\begin{tikzpicture}
			\draw[dashed] (-3,0) -- (-3,-5.5) (3,0) -- (3,-5.5);
			\node at (-3,.3) {Sender};
			\node at (3,.3) {Receiver};

			\draw[-Latex] (-3,-.5) -- node[midway,above=.3em] {Packet 0} (3,-1);
			\draw[-Latex, dashed] (3,-1) -- node[midway,below=.3em] {ACK 0} (-3,-1.5);

			\draw[-Latex] (-3,-2.25) -- node[midway,above=.3em] {Packet 1} (3,-2.75);
			\draw[color=red, dash pattern=on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 99pt] (3,-2.75) -- node[midway,below=.3em] {ACK 1} (-3,-3.25);
			\node[color=red] at ($(3,-2.75)!129pt!(-3,-3.25)$) {$\times$};

			\node[anchor=east] at (-3,-4) {\large \showclock{0}{15}};
			\draw[-Latex] (-3,-4) -- node[midway,above=.3em] {Packet 1} (3,-4.5);
			\node[anchor=west, draw=black] at (3,-4.5) {?};

			\draw[-Latex, dashed] (3,-4.5) -- node[midway,below=.3em] {ACK 1} (-3,-5);
		\end{tikzpicture}
		\caption{Lost ACK}
		\label{fig:sawe-lack}
	\end{subfigure}
	\caption{Stop-and-Wait ARQ: dropped packet scenarios}
\end{figure}

Figure~\ref{fig:sawe-lost} shows Packet 1 never reaches the receiver. Since the receiver hasn't received Packet 1, it never sends an ACK. After a short time when the sender receives no ACK, it re-sends Packet 1 and upon receipt, the receiver sends an ACK and transmission continues.

In Figure~\ref{fig:sawe-lack}, Packet 1 reaches the receiver, but the corresponding ACK doesn't reach the sender. From the sender's perspective, this is the same situation as in Figure~\ref{fig:sawe-lost}, so it re-sends Packet 1 after a short timeout. This is when the 1-bit sequence number comes into play. When the receiver reads the re-transmitted Packet 1, it \textit{discards its contents} (because it has already seen this data - it knows this because of the sequence number) and sends another ACK.

\newpage
\subsubsection{Go-Back-N ARQ} \label{sec:gbn}
Although Stop-and-Wait ARQ can correct errors, it wastes bandwidth by allowing only a single data packet to be in-transit at once. Go-Back-N attempts to improve this through use of a sender ``sliding window''. Essentially, a sender can transmit up to $n$ packets (where $n$ is the window size) before needing to wait for the receiver to send an ACK.

\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\draw[dashed] (-3,0) -- (-3,-6) (3,0) -- (3,-6);
		\node at (-3,.3) {Sender};
		\node at (3,.3) {Receiver};

		\node[anchor=west] at (3,-.25) {\begin{tabular}{|c|}\hline \cellcolor{green!35}0 \\ \hline\end{tabular}};
		\node[anchor=west] at (3,-1.75) {\begin{tabular}{|c|}\hline \cellcolor{green!35}1 \\ \hline\end{tabular}};
		\node[anchor=west] at (3,-3.25) {\begin{tabular}{|c|}\hline \cellcolor{green!35}2 \\ \hline\end{tabular}};
		\node[anchor=west] at (3,-5) {\begin{tabular}{|c|}\hline \cellcolor{green!35}3 \\ \hline\end{tabular}};

		\draw[-Latex] (-3,-.75) -- node[midway,above=.3em] {Packet 0} (3,-1.25);

		\draw[-Latex] (-3,-2.25) -- node[midway,above=.3em] {Packet 1} (3,-2.75);
		\draw[-Latex, dashed] (3,-2.75) -- node[midway,below=.3em] {ACK 1} (-3,-3.25);

		\draw[-Latex] (-3,-4) -- node[midway,above=.3em] {Packet 2} (3,-4.5);
		\draw[-Latex, dashed] (3,-4.5) -- node[midway,below=.3em] {ACK 2} (-3,-5);

		\node[anchor=east] at (-3,-.25) {\begin{tabular}{|c|c|c|c|c|c|}\hline \cellcolor{blue!35}0&\cellcolor{blue!35}1&\cellcolor{blue!35}2&3&0&1 \\ \hline\end{tabular}};
		\node[anchor=east] at (-3,-3.6) {\begin{tabular}{|c|c|c|c|c|c|}\hline 0&1&\cellcolor{blue!35}2&\cellcolor{blue!35}3&\cellcolor{blue!35}0&1 \\ \hline\end{tabular}};
		\node[anchor=east] at (-3,-5.35) {\begin{tabular}{|c|c|c|c|c|c|}\hline 0&1&2&\cellcolor{blue!35}3&\cellcolor{blue!35}0&\cellcolor{blue!35}1 \\ \hline\end{tabular}};
	\end{tikzpicture}
	\caption{Go-Back-N ARQ: normal scenario}
	\label{fig:gbn-ok}
\end{figure}

The blue shaded numbers in Figure~\ref{fig:gbn-ok} represent the current send window - when an ACK is received the window shifts forward past the number in the ACK packet. This means that not every packet \textit{has} to be acknowledged. Also of note is the fact that the size of the window is 1 less than the highest sequence number. This is important for handling errors. The window size can therefore be calculated as $2^m - 1$ where $m$ is the number of bits used for the sequence number.

The green shaded numbers on the right represent the receiver ``window''. This is the only sequence number packet that the receiver will accept at that point, others will be ignored. On receipt of a packet, this number is incremented (wrapping around of course) and an acknowledgement packet is usually sent.

\medskip
If data packets or ACK's are lost, after a short timeout the sender will re-send all of the packets in the current send window (similarly to Stop-and-Wait ARQ). The requirement for $w = 2^m - 1$ can be understood by looking at the following error scenario:
\begin{figure}[h!]
	\centering
	\begin{tikzpicture}
		\draw[dashed] (-3,0) -- (-3,-7.25) (3,0) -- (3,-7.25);
		\node at (-3,.3) {Sender};
		\node at (3,.3) {Receiver};

		\node[anchor=west] at (3,-.25) {\begin{tabular}{|c|}\hline \cellcolor{green!35}2 \\ \hline\end{tabular}};
		\node[anchor=west] at (3,-1.75) {\begin{tabular}{|c|}\hline \cellcolor{green!35}3 \\ \hline\end{tabular}};
		\node[anchor=west] at (3,-6.75) {\begin{tabular}{|c|}\hline \cellcolor{green!35}0 \\ \hline\end{tabular}};

		\draw[-Latex] (-3,-.75) -- node[midway,above=.3em] {Packet 2} (3,-1.25);
		\draw[color=red, dash pattern=on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 3pt on 3pt off 99pt] (3,-1.25) -- node[midway,below=.3em] {ACK 2} (-3,-1.75);
		\node[color=red] at ($(3,-1.25)!129pt!(-3,-1.75)$) {$\times$};

		\node[anchor=east] at (-3,-2.5) {\large \showclock{0}{15}};
		\draw[-Latex] (-3,-2.5) -- node[midway,above=.3em] {Packet 0} (3,-3);
		\draw[-Latex] (-3,-3.25) -- node[midway,above=.3em] {Packet 1} (3,-3.75);
		\draw[-Latex] (-3,-4) -- node[midway,above=.3em] {Packet 2} (3,-4.5);
		\draw[-Latex, dashed] (3,-4.5) -- node[midway,below=.3em] {ACK 2} (-3,-5);

		\draw[-Latex] (-3,-5.75) -- node[midway,above=.3em] {Packet 3} (3,-6.25);

		\node[anchor=east] at (-3,-.25) {\begin{tabular}{|c|c|c|c|c|c|}\hline \cellcolor{blue!35}0&\cellcolor{blue!35}1&\cellcolor{blue!35}2&3&0&1 \\ \hline\end{tabular}};
		\node[anchor=east] at (-3,-5.35) {\begin{tabular}{|c|c|c|c|c|c|}\hline 0&1&2&\cellcolor{blue!35}3&\cellcolor{blue!35}0&\cellcolor{blue!35}1 \\ \hline\end{tabular}};
	\end{tikzpicture}
	\caption{Go-Back-N ARQ: many ACK's lost}
	\label{fig:gbn-bad}
\end{figure}

\newpage
In Figure~\ref{fig:gbn-bad}, it can be assumed that the sender has sent packets 0 and 1 (with no ACK from the receiver) before this diagram starts.

When the sender fails to receive any acknowledgement, it re-sends all of the packets in the window as described above. The receiver's expected packet doesn't change since it has already received packets 0 to 2, but it sends an ACK at the end. Note that if the packets 0 through 3 had been sent without acknowledgement (and re-sent again after a timeout), the receiver would have wrapped around and \textbf{accept the the re-sent packets as new data}!

\section{Implementation}
The implementation of the assignment is called ``JQTT'' (Jack's Queueing Telemetry Transport).
\subsection{Design choices / features}
\begin{itemize}
	\item Rust was used as the main language for its high-level features combined with high performance \cite{rust-lang}
	\item The assignment was split into a number of subprojects:
		\begin{itemize}
			\item \mi{c}{pubsub-broker}: JQTT broker library
			\item \mi{c}{pubsub-client}: JQTT publisher / subscriber library
			\item \mi{c}{pubsub-common}: Common code used by broker / client
			\item \mi{c}{pubsub-server}: Command line application which starts a broker using the \mi{c}{pubsub-broker} library
			\item \mi{c}{pubsub-demos}: Additional mini command line demos
			\item \mi{c}{pubsub-interactive}: Interactive client demo with publish / subscribe in an \mi{c}{ncurses}-like UI
		\end{itemize}
	\item Go-Back-N was used as the flow control method of choice (with a window size of 15)
	\item Messages can (in theory) be up to 4GB (32-bit) in size thanks to multi-packet messages
	\item More than one multi-packet message can be in-flight at a time
	\item A Wireshark dissector was written for the wire protocol to make debugging easier
\end{itemize}

\subsection{Protocol} \label{sec:protocol}
The JQTT protocol is made up of 9 different packet types. Each is made up of a 1 byte header and (usually) some kind of payload. All integers are represented in network / big endian. The header looks like this:

\newcommand*{\tn}[2]{\tikz[baseline,remember picture]\node[inner sep=0pt,outer sep=2pt,anchor=base] (#1) {#2};}
\begin{figure}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		\cellcolor{red!30}\tn{type-start}{0} &\cellcolor{red!30}0&\cellcolor{red!30}1& \cellcolor{red!30}\tn{type-end}{1} & \cellcolor{blue!30}\tn{seq-start}{0} &\cellcolor{blue!30}1&\cellcolor{blue!30}0& \cellcolor{blue!30}\tn{seq-end}{0} \\
		\hline
	\end{tabular}

	\begin{tikzpicture}[remember picture, overlay]
		\draw[decorate, decoration={brace,amplitude=5pt,mirror,raise=5pt}] (type-start.south west) -- (type-end.south east) node[midway, below=10pt] {Type (\mi{c}{ACK})};
		\draw[decorate, decoration={brace,amplitude=5pt,mirror,raise=5pt}] (seq-start.south west) -- (seq-end.south east) node[midway, below=10pt] {Sequence no. (\mi{c}{4})};
	\end{tikzpicture}
	\vspace*{10pt}
	\caption{Header layout}
	\label{fig:packet-header}
\end{figure}

Figure~\ref{fig:packet-header} shows the first four bits of the header represent the packet type (in the range \mi{c}{0} to \mi{c}{8} inclusive).

The last 4 bits represent the sequence number of the packet, if relevant. In this example, the packet is an acknowledgement for the packet with sequence number 4. For unordered packets (such as \mi{c}{HEARTBEAT}), the contents of these bits is irrelevant.

\newpage
\subsubsection{Wireshark dissector}
The Wireshark dissector for this assignment was written in Lua (see \mi{c}{wireshark_dissector.lua}). Drop it into the plugin folder of your local Wireshark installation (\mi{c}{~/.local/lib/wireshark/plugins} on Linux) to install it. When enabled, JQTT packets will be decoded:

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{dissector}
	\caption{JQTT packets decoded in Wireshark}
	\label{fig:dissector}
\end{figure}

Figure~\ref{fig:dissector} shows JQTT packets decoded from raw UDP with detailed output. The filter field can be used to show only certain packets based on field values. In this example, \mi{c}{jqtt && !jqtt.type == HEARTBEAT} will show only JQTT packets that aren't of the \mi{c}{HEARTBEAT} type. Clicking on the 'Expression\dots' button and expanding the 'JQTT' tree will show possible field names and a brief explanation.

The 'Info' column shows the source and destination port numbers, the packet type (in square brackets) and the sequence number (if applicable).

Selecting a packet and expanding the JQTT section will show the packet type, sequence number as well as any packet-specific payload information. Clicking on a field will highlight the portion of the hex dump view its contents represents.

\newpage
\subsection{Packet types}
As explained in section~\ref{sec:protocol}, there are 9 distinct pacet types in JQTT. The structure and purpose of each is explained in detail in this section (in order of the type number given to each; \mi{c}{CONNECT} is \mi{c}{0}, \mi{c}{CONNACK} is \mi{c}{1} etc.).

\subsubsection{\mi{c}{CONNECT}}
The \mi{c}{CONNECT} packet is sent by any client (publisher / subscriber or both) to establish a ``connection'' state with a broker. The packet type is \mi{c}{0} and the sequence bits are unused. 4 magic bytes appear after the header in the form of the ASCII representation of the string ``JQTT''.

In response to this packet the broker will send a \mi{c}{CONNACK} packet. After this the server will no longer accept \mi{c}{CONNECT} packets from this client until it disconnects or times out (if \mi{c}{keepalive} is enabled). If the client fails to receive a \mi{c}{CONNACK} response within a certain time, it will send another \mi{c}{CONNECT} packet (up to 5 times).

\subsubsection{\mi{c}{CONNACK}}
Upon receiving a \mi{c}{CONNECT} packet from a client, the broker will send a \mi{c}{CONNACK} packet in reponse (as described above). It contains:
\begin{itemize}
	\item A flags bitfield (in place of the sequence number bits) - currently the only flag (the lowest bit) is whether the broker has \mi{c}{keepalive} mode enabled (see section~\ref{sec:heartbeat} on the \mi{c}{HEARTBEAT} packet)
	\item A 16-bit unsigned integer representing the maximum packet size (including the 1 byte header) - this affects the packet types with variable length payloads
\end{itemize}

\subsubsection{\mi{c}{HEARTBEAT}} \label{sec:heartbeat}
Under \mi{c}{keepalive} mode, clients must send a \mi{c}{HEARTBEAT} packet to the broker every few seconds. The server will respond to each \mi{c}{HEARTBEAT} packet with its own. If either the server or the client has not received a \mi{c}{HEARTBEAT} packet within the last 5 seconds, it will consider the peer as ``timed out'' and ``disconnect'' it (sending a \mi{c}{DISCONNECT} packet).

In terms of structure, \mi{c}{HEARTBEAT} is very simple. It contains only the 1-byte JQTT header with all of the sequence bits set to 0 since it is not packet which needs to be delivered in the correct order (or at all, since it contains no information and another will take its place if lost).

\subsubsection{\mi{c}{ACK}}
The \mi{c}{ACK} packet simply fills the acknowledgement packet role required for Go-Back-N (as described in section~\ref{sec:gbn}). It is sent by both clients and the broker for all ordered packets.

Like \mi{c}{HEARTBEAT}, \mi{c}{ACK} is consists of only the 1-byte header. The sequence bits represent the sequence number of the packet being acknowledged.

\subsubsection{\mi{c}{DISCONNECT}}
\mi{c}{DISCONNECT} can be sent to either clients or a broker to indicate that the ``connection'' between the two should be stopped. It can be sent for a variety of reasons:
\begin{itemize}
	\item A client is terminating and informs the server
	\item The broker is terminating and is informing all clients
	\item A client / broker timed out in \mi{c}{keepalive} mode
	\item A malformed / invalid packet was received by a client or broker
	\item There was an error sending a packet (e.g. operating system related)
\end{itemize}

This is another header-only packet. The sequence bits are used since \mi{c}{DISCONNECT} needs to be delivered reliably.

\subsubsection{\mi{c}{SUBSCRIBE}}
When a client wishes to subscribe to messages published to a topic, it sends a \mi{c}{SUBSCRIBE} packet. The broker will add the client to the list of subscribers for that topic and dispatch any messages that arrive \textit{after} subscribing (the broker will not dispatch messages to a subscriber that were published to a topic prior to subscription).

\medskip
\mi{c}{SUBSCRIBE} obviously makes use of the sequence bits since it should be delivered reliably. After the header, the remainder of the packet is a UTF-8 encoded string (\textbf{not} null-terminated). Since a UDP packet has a distinct size, the length of the string can be determined by subtracting 1 (for the header) from the UDP payload size.

\medskip
Note that the maximum packet length (as provided by the broker to clients in the \mi{c}{CONNACK} packet) determines the longest possible topic length! See section~\ref{sec:pubstart} for an explanation on how the maximum length of a topic string is calculated.

\subsubsection{\mi{c}{UNSUBSCRIBE}}
The \mi{c}{UNSUBSCRIBE} packet is very simple. When a broker receives this packet it will remove the client from the list of subscribers for that topic. The client will no longer receive any messages published to that topic. Its structure is identical to that of \mi{c}{SUBSCRIBE}.

\subsubsection{\mi{c}{PUBLISH_START}} \label{sec:pubstart}
This is one of the most important packets. \mi{c}{PUBLISH_START} contains information about a message which is about to me published in one or more \mi{c}{PUBLISH_DATA} packets. It can be sent by both clients \textit{and} brokers depending on the context:
\begin{itemize}
	\item Clients send this packet when they wish to publish a message to a topic
	\item A broker will send this packet to all subscribers of a topic upon receiving a \mi{c}{PUBLISH_START} packet from a client (\textbf{with the exception of the publisher of the message})
\end{itemize}

\mi{c}{PUBLISH_START} contains 3 fields, they are (in order of appearance in the packet):
\begin{itemize}
	\item Message ID: A 32-bit unsigned integer which allows multiple messages to be ``in-flight'' simultaneously. Since message data is split across a multitude of \mi{c}{PUBLISH_DATA} packets, this is very useful (especially if a large message is in the process of being sent). Also of note is the fact that this ID is different based on who sent the packet. If it was sent by a client (asking a broker to publish a message to subscribers), it is unique to that client only. When a server is dispatching the \mi{c}{PUBLISH_START} to subscribers, it will overwrite the message ID with a value unique across all subscribers of all topics the broker holds.
	\item Message size: Another 32-bit unsigned integer which indicates the size (in bytes) of the message payload (to be split across a number of \mi{c}{PUBLISH_DATA} packets)
	\item Topic: This is a UTF-8 encoded string indicating the topic to which this message should be published. As with \mi{c}{SUBSCRIBE} and \mi{c}{UNSUBSCRIBE}, the length of this string is determined by the remaining bytes in the UDP payload. \textbf{The largest possible topic is determined by this packet - this applies to \mi{c}{SUBSCRIBE} and \mi{c}{UNSUBSCRIBE} too since a topic name could conceivably fit into these smaller packets but \underline{not} in a \mi{c}{PUBLISH_START} packet.}
\end{itemize}

\subsubsection{\mi{c}{PUBLISH_DATA}}
Where \mi{c}{PUBLISH_START} starts the publishing process for a message, \mi{c}{PUBLISH_DATA} contains (at least some of) the actual message payload.

Like \mi{c}{PUBLISH_START}, it can be sent by either the client (if that client is the one publishing the message) or a broker (distributing the message to subscribers on behalf of the publisher). This packet consists of two fields:
\begin{itemize}
	\item Message ID: A 32-bit unsigned integer which must match that of a preceding \mi{c}{PUBLISH_START} packet - if a data packet is sent without a start packet, the receiver will complain. The same applies if a data packet is sent and the total transmitted data for that message ID would exceed the value set in the initial \mi{c}{PUBLISH_START} packet.
	\item Actual (partial) message payload: The remainder of the packet is data \textbf{of an arbitrary format}. A publisher will split the full payload into a number of \mi{c}{PUBLISH_DATA} packets based on the maximum packet size set out in the \mi{c}{CONNACK} packet for the connection. When subscribers receive the published packets from a broker they will re-assemble the segments into the original payload.
\end{itemize}

\subsection{Code overview}
The implementation of the protocol described above (as well as a number of sample programs) is divided into a number of Rust crates. An overview of these will be given here.

\subsubsection{\mi{c}{pubsub-common}}
This crate contains code shared by the client and broker crates. Mainly this consists of packet encoding / decoding, the actual Go-Back-N implementation (both in \mi{c}{protocol.rs}), a timer management struct (\mi{c}{timer.rs}) and some other constants and utility functions.

\medskip
\noindent \textbf{Timer manager}

\smallskip
\noindent \mi{c}{timer.rs} contains a struct (\mi{rust}{TimerManager}) which dispatches messages (through user provided callbacks) at a specified time. This is implemented primarily through the use of a priority queue (provided by the \mi{rust}{priority-queue} crate) and a single background thread. Timers can be cancelled or re-scheduled.

When a timer is created, it is inserted into the priority queue (the soonest timer is at the front of the queue). The background thread will sleep until the timer at the front of the queue should be triggered, then it will invoke that timer's callback with the stored message before returning to sleep until the next timer's message should be dispatched.

Note that because a new timer could be created which should be triggered before the one currently at the front of the queue, the background thread will always be woken up after the timer has been inserted into the priority queue.

\mi{rust}{TimerManager} is used primarily to implement the timeout and re-sending of the Go-Back-N window, but is also used to inform of timeouts under \mi{c}{keepalive} mode (and to schedule regular transmission of \mi{c}{HEARTBEAT} packets by clients).

\medskip
\noindent \textbf{Protocol encoding / decoding}

\smallskip
\noindent The \mi{rust}{protocol} module contains a number of structs, the primary one being \mi{rust}{Jqtt}. Used by both the client and broker, it handles decoding incoming bytes into a \mi{c}{Packet} enum variant (in the \mi{rust}{decode()} function as well as encoding and dispatching packets via the \mi{rust}{send_*()} functions.

\mi{rust}{gbn_send()} will either write a packet to the wire and place it into the send window, or queue it up for later transmission in a separate send buffer. The send window and send buffer are represented as linked lists. Each packet also gets a locally stored packet ID which can be used later to determine if that packet has been successfully delivered (acknowledged).

Upon receipt of an \mi{c}{ACK}, the current \mi{c}{ACK} timeout timer (also managed by the \mi{rust}{Jqtt} struct) is cancelled. The acknowledged packets are then dropped from the send window. If there are packets in the send buffer, the free space in the send with those and they are written to the socket. The \mi{c}{ACK} timeout timer is also restarted.

If an \mi{c}{ACK} timeout occurs, all of the packets in the send window will be re-transmitted.

\subsubsection{\mi{c}{pubsub-broker}}
This crate contains a library which implements the broker side of the JQTT protocol. The only publicly accessible struct is \mi{c}{Broker}, which handles all aspects of the protocol for a crate user.

\medskip
\noindent\mi{rust}{Broker} will create a UDP socket (and corresponding IO thread) on each provided address. A number of worker threads will also be created to handle clients. Incoming data is truncated to the specified maximum packet sizes (for IPv4 and IPv6 respectively). When a packet is received, it is handed to the worker manager.

\mi{rust}{WorkerManager} will then check if state (\mi{rust}{Client}) already exists for the source address of the packet. If so, it will pass the packet to the \mi{rust}{Clients} struct for handling. Otherwise, a new \mi{rust}{Client} struct will be created and assigned a worker thread (selected in a round-robin fashion each time a new client connects).

\mi{rust}{Clients} (in the \mi{c}{client} module) maintains a hashtable (provided by the \mi{rust}{evmap} crate) of client addresses mapped to a \mi{rust}{Client} struct and a pointer to its assigned worker's packet queue (provided by the \mi{rust}{crossbeam} queue). When the worker manager calls \mi{rust}{dispatch()}, \mi{rust}{Clients} will post the packet to the appropriate worker queue.

\mi{rust}{Worker}'s thread runs in a loop waiting for messages in its queue (usually packets from assigned clients). When a packet arrives from \mi{rust}{Clients}, the worker will call the \mi{rust}{Client}'s \mi{rust}{handle()} function. This will handle simple packets (such as \mi{c}{CONNECT} - a \mi{c}{CONNACK} response will be sent appropriately). When message-related packets arrive, \mi{rust}{Client} will use \mi{rust}{MessageMapping} to translate the client-only message ID to a globablly-valid (for the broker) one. \mi{rust}{MessageInfo} is used to track whether the message has been fully received (so the information can be dropped and the message ID can be re-used).

For \mi{c}{(UN)SUBSCRIBE} packets, \mi{rust}{Client} will return an \mi{rust}{Action} enum variant and the worker will access the \mi{rust}{Subscriptions} struct (wrapping another hashtable mapping topics to a set of client addresses) to perform the appropriate action.

After translating the message ID's for \mi{rust}{PublishStart} / \mi{rust}{PublishData} packets, an \mi{rust}{Action} enum variant is returned by \mi{rust}{Client::handle()}. The worker will then dispatch the translated packet to all subscribers (obtained from the \mi{rust}{Subscriptions} struct).

The worker will also handle \mi{c}{ACK} timeouts (calling \mi{rust}{Jqtt::handle_ack_timeout()}) and \mi{c}{HEARTBEAT} timeouts (sending \mi{c}{DISCONNECT} if \mi{c}{keepalive} mode is enabled).

\subsubsection{\mi{c}{pubsub-client}}
The \mi{c}{pubsub-client} crate provides a client library to establish a connection to a broker and publish / receive messages.

\medskip
\noindent Users can call \mi{rust}{Client::connect()} (or alternatively \mi{rust}{Client::connect_timers()} to re-use an existing \mi{rust}{TimerManager}) to establish a connection to a broker listening on the provided address. I/O and work threads will be created once the broker has responded with a \mi{c}{CONNACK}.

\mi{rust}{ClientInner} is analogous to \mi{c}{pubsub-broker} \mi{rust}{Client}. The worker thread, upon receiving a packet from the I/O thread, will call \mi{rust}{Client::handle()}. If a \mi{c}{PublishStart} or \mi{c}{PublishData} packet is received, the user-provided listener will be called.

The worker thread will handle timeouts as the worker's does. Any errors will be passed to the user's listener.

When the user wishes to subscribe to / unsubscribe from a topic, they can call \mi{rust}{Client::subscribe()} and \mi{rust}{Client::unsubscribe()} respectively. These will block until the broker acknowledges the \mi{c}{SUBSCRIBE} / \mi{c}{UNSUBSCRIBE} packets. This achieved using \mi{rust}{std::sync::Condvar}'s in conjunction with the \mi{c}{pubsub-common} \mi{rust}{Jqtt} to wait until there is space available in the send buffer and then that the packet ID has been acknowledged.

\medskip
\noindent If the user wishes to send a message, they can pass a \mi{rust}{Message} struct (from the \mi{c}{messaging} module) to \mi{rust}{Client::queue_message()}. \mi{rust}{Message} requires that the user provide the total size of the message, the topic the message should be published to and an implementation of \mi{rust}{std::io::Read} (e.g. \mi{rust}{std::fs::File}, or \mi{rust}{std::io::Cursor} wrapping a buffer, or even another network resource). A client message ID will be chosen and a \mi{rust}{MessageInfo} struct will be created (generating the \mi{c}{PUBLISH_START} packet). This will then be placed in the message queue. \textbf{No data will be sent at this time}, allowing for a number of messages to be queued up before being transmitted in parallel.

In order to actually send the queued messages, \mi{rust}{Client::drain_messages()} should be called. In a loop which terminates when the message queue is empty, the following steps take place:
\begin{enumerate}
	\item Wait until there is space in the send buffer for at least 32 packets
	\item While there is still space in the send buffer:
		\begin{enumerate}
			\item Select the next message in the queue
			\item Generate the next packet for the currently selected message (by reading some bytes from its stream to fill the payload for \mi{rust}{PUBLISH_DATA}) and call \mi{rust}{Jqtt::gbn_send()} to send it
			\item If the message has been fully sent, remove it from the queue
		\end{enumerate}
	\item Wait for the last transmitted packet to be acknowledged (i.e. all sent packets have been acknowledged under Go-Back-N)
\end{enumerate}

\medskip
\noindent Although the user-provided listener allows incoming messages to be streamed (useful if a very large message is being received and it would be undesirable to keep the whole thing in memory), often it is more desirable to be able get a callback when a message has been completely received.

\mi{rust}{MessageCollector} performs this task, handling parallel messages and combining received \mi{c}{PUBLISH_DATA} packets into a \mi{rust}{Message} and passing it to the user-provided callback.

\subsubsection{\mi{c}{pubsub-server}}
While \mi{c}{pubsub-broker} only provides a library and no executable, \mi{c}{pubsub-server} provides a simple binary which allows you to set the following options through command line switches:
\begin{itemize}
	\item Log level (defaults to \mi{c}{INFO}, each instance of \mi{c}{-v} passed increases verbosity by one level)
	\item Bind address(es)
	\item Worker thread count (defaults to $n_{cpus} - 1$)
	\item Maximum packet size (defaults to a minimum safe value for UDP under IPv4 and IPv6 \cite{udp-safe})
\end{itemize}

\subsubsection{\mi{c}{pubsub-demos}}
This crate provides a few simple demos - note that a broker must be running already for these to work (e.g. via \mi{c}{pubsub-server}):
\begin{itemize}
	\item \mi{c}{big-publish}: This demo will create a single client send:
		\begin{itemize}
			\item Send one 512MB message (of zeroes) and report send statistics
			\item Send two 512MB messages (in parallel) and report send statistics
		\end{itemize}
		With no subscribers to the ``/dev/zero'' topic, release build performance is approximately 119.22MB/s for a single message and 58.51MB/s for two (IPv6 across the loopback interface with the default packet size on a 16-core AMD Threadripper 1950x @ 4.0GHz).

	\item \mi{c}{big-receive}: Receives a single message from the ``/dev/zero'' topic, reports receive statistics and exits. Receiving the first message on the same system as above runs at approximately 94.79MB/s.
	\item \mi{c}{scale}: A demo to test the scaling possibilites of the codebase. It does the following:
		\begin{enumerate}
			\item Sets up 100 subscribers for each of 4 sample topics (a total of 400 subscribers)
			\item Starts 10 publishers for each topic (total of 40, each publishing 100 1KB messages with an interval of 200 to 300ms)
			\item Waits for all publishers to complete publishing and all subscribers to receive all messages (a total of 400000 messages across all 400 subscribers)
		\end{enumerate}
	Note that due to limitations in the way that the broker's worker threads handle dispatching messages, it may be necessary to disable keepalive mode for this to complete successfully
\end{itemize}

\subsubsection{\mi{c}{pubsub-interactive}}
While \mi{c}{pubsub-demos} provides a set of one-shot programs for testing the protocol, \mi{c}{pubsub-interactive} is more of a user front-end for the client library, featuring a terminal user interface using the \mi{rust}{cursive} crate (similar to \mi{c}{ncurses}).

Its interface looks like a chat program, with a message log at the top and an entry box at the bottom. A number of commands are provided:
\begin{itemize}
	\item \mi{c}{help}: Lists available commands
	\item \mi{c}{subscribe}: Subscribe to a topic
	\item \mi{c}{unsubscribe}: Unsubscribe from a topic
	\item \mi{c}{publish}: Publish a message to a topic
\end{itemize}

Received messages will be printed in the log (if their payloads are valid UTF-8). Pressing \mi{c}{^C} (Ctrl-C) or sending \mi{c}{SIGINT} / \mi{c}{SIGTERM} will exit the program cleanly.

\section{Reflection / limitations}
Overall, a reasonably solid protocol and codebase was developed. There are some limitations in both the protocol and implementation however:
\begin{itemize}
	\item Selective-Repeat-ARQ might be a better flow / error control setup
	\item There is no provision for clients who acknowledge messages slower than they are sent. One side effect of this is that it limits the possibility of delegating the dispatch of messages onto a separate thread (so that other packets from the publisher could be processed, e.g. avoiding the \mi{c}{keepalive} server timeout problem that occurs when there are a lot of subscribers to a single topic). New packets would likely be required to ask publishers to slow their rate of transmission when a broker's send buffer for a slow client fills up, as well as logic to drop troublesome subscribers who are slowing everybody else down.
	\item Combining multiple packet into a single UDP payload would be more efficient than sending them separately (e.g. \mi{c}{SUBSCRIBE}, \mi{c}{PUBLISH_START} and \mi{c}{PUBLISH_DATA} packets could be combined into a single packet if they fit). This would require very significant changes to both the protocol and consequentially the implementation.
\end{itemize}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{References}
\printbibliography

\end{document}
# vim: nofoldenable
